## Story Log

### Goal
Implement automatic cache writing when commands reference or display items.

### Why
Shell completion needs a pre-computed cache of recently used aliases and context tags. By automatically capturing these during normal command usage (mm ls, mm note, etc.), users get working completion without any extra effort. IDs are not cached for completion since they are long UUIDs not meant for manual typing; aliases serve this purpose.

### User Story
**As a** mm user, **I want** commands to automatically record used items to a cache file, **so that** shell completion can suggest recently accessed aliases and tags.

### Acceptance Criteria

#### 1. Cache File Creation
- [ ] **Given** a workspace exists, **When** you run any command that references an item (e.g., `mm edit <alias>`), **Then** `.index/completion_cache.jsonl` is created if it doesn't exist
- [ ] **Given** no workspace is active, **When** you run a command, **Then** no cache file is created and no error occurs

#### 2. Cache Format (JSONL)
- [ ] **Given** a command creates an item, **When** you inspect the cache file, **Then** it contains valid JSONL with `type` ("alias" or "tag"), `value`, `canonical_key`, `target` (for aliases), and `last_seen` fields
- [ ] **Given** an item has an alias, **When** the item is cached, **Then** an alias entry is written with the `target` field pointing to the item's UUID
- [ ] **Given** an item has a context tag, **When** the item is cached, **Then** tag entries are written to the cache

#### 3. Cache Population from Arguments
- [ ] **Given** you run `mm edit <alias>`, **When** the command completes successfully, **Then** the cache contains an entry for that alias
- [ ] **Given** you run `mm close <alias>`, **When** the command completes successfully, **Then** the cache contains an entry for the alias
- [ ] **Given** you run `mm note "Hello" --context work`, **When** the command completes successfully, **Then** the cache contains an entry for the tag "work"
- [ ] **Given** you run a command that fails, **When** the command exits with an error, **Then** the cache is not updated

#### 4. Cache Population from Results
- [ ] **Given** you run `mm note "Hello"`, **When** the command successfully creates an item, **Then** the cache contains an entry for the new item's auto-generated alias
- [ ] **Given** you run `mm ls`, **When** items are successfully displayed, **Then** the cache contains entries for all displayed items' aliases and context tags

#### 5. Atomic Writes
- [ ] **Given** the cache file exists, **When** a command updates the cache, **Then** the update uses atomic rename (write to .tmp, then rename) to prevent corruption

#### 6. Compaction
- [ ] **Given** 10 cache writes have occurred OR the cache file exceeds 50KB, **When** the next command updates the cache, **Then** compaction is triggered
- [ ] **Given** compaction runs, **When** processing cache entries, **Then** duplicates are removed by `(type, canonical_key)` keeping the entry with the most recent `last_seen`
- [ ] **Given** compaction runs, **When** an alias target has changed, **Then** the alias entry is updated with the new target UUID
- [ ] **Given** compaction runs, **When** sorting entries, **Then** entries are sorted by `last_seen` (newest first) before truncating to 1000 entries
- [ ] **Given** compaction runs with concurrent writers, **When** writing the compacted cache, **Then** advisory locking or retry logic prevents data loss

#### 7. Error Cases
- [ ] **Given** the cache file is read-only, **When** a command tries to update the cache, **Then** the cache write fails silently without breaking the command
- [ ] **Given** a cache line is malformed, **When** compaction runs, **Then** the malformed line is skipped and valid lines are preserved

### Out of Scope
- Shell completion script generation (Subsquent story)
- Shell script integration for reading the cache (Subsquent story)
- Advanced compaction strategies (e.g., detecting stale aliases)

---

### Completed Work Summary
Not yet started.

### Acceptance Checks

**Status: Pending Product Owner Review**

Developer verification completed:
- [To be filled after implementation]

**Awaiting product owner acceptance testing before marking this user story as complete.**

### Follow-ups / Open Risks

#### Addressed
- [To be filled during implementation]

#### Remaining
- [To be filled during implementation]
