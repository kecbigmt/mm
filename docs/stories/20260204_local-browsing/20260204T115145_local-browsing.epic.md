# Local Browsing UI – DESIGN

Status: Draft
Target version: 0.x

---

## 0. Scope & Non-Scope

### In Scope (initial release)

* **Fresh-based local web UI** for browsing mm workspace nodes (SSR + islands)
* **Core routes**: date listings (`/d/:date`), item details (`/i/:id`), alias resolution (`/a/:alias`), tree view (`/tree/:rootId`), basic search (`/search`)
* **In-memory indexing** on startup: load all items from frontmatter, build `itemsById`, `childrenByContainer`, `aliasToId` maps
* **Placement-based navigation**: resolve relative dates (`today`, `tm`) to absolute dates at request time
* **Rank-based ordering**: display children by rank (ascending), tie-break by `created_at`
* **Markdown rendering**: full item body on detail pages, title/excerpt on list pages
* **Basic interactivity**: tree expansion/collapse, search filtering (via islands)
* **Workspace timezone support**: read timezone from `workspace.json`, use for date resolution
* **Development server**: `deno task fresh-dev` for local browsing during development

### Out of Scope (future work)

These features are explicitly outside of the initial release:

* **Public/SSG export**: Publishing to static sites (Astro/etc.) via `mm export` command
* **Public filter logic**: Determining which items are public/private (visibility rules)
* **Authentication/authorization**: No login, no access control (local-only for now)
* **Real-time updates**: No live reload when workspace changes on disk
* **Advanced search**: Full-text indexing, tag filters, complex queries
* **Editing capabilities**: No CRUD operations through the UI (read-only)
* **Mobile-optimized UI**: Responsive design, but not mobile-first
* **Theme customization**: Single default theme

---

## 1. Motivation & Goals

**Why**: mm users need a way to browse their knowledge graph visually. The CLI is powerful but not ideal for exploration, discovering connections, or reviewing daily notes. A local web UI provides:

- **Visual navigation** through the item hierarchy
- **Quick access** via aliases and dates
- **Context-rich display** of relationships (parent, children, placement)
- **Foundation for future public export** (reusable graph traversal logic)

Design goals:

1. **Frontmatter as source of truth**
   All navigation and display logic reads from item frontmatter (`placement`, `rank`, `status`, etc.). The `.index/` directory is treated as a rebuildable cache, not authoritative.

2. **Fast startup and response**
   With ~1000 items, in-memory indexing is viable. Build `itemsById` and `childrenByContainer` maps at startup; serve pages with minimal disk I/O.

3. **Canonical placement resolution**
   User-facing paths (e.g., `today`, `tm`, aliases) are resolved to canonical placements (absolute dates + UUIDs) at request time. Frontmatter stores only canonical forms.

4. **SSR-first, islands for interactivity**
   Render most content server-side (fast, SEO-friendly, works without JS). Use islands only for interactive features (tree toggle, search filter).

5. **Prepare for SSG export**
   Structure domain logic (graph traversal, placement resolution) to be reusable for future `mm export` command that generates static sites.

---

## 2. Terminology

* **Item** — A node in the knowledge graph (note, task, event). Has UUID, frontmatter, markdown body.
* **Placement** — Canonical location of an item: `date:YYYY-MM-DD` or `parent:<uuid>|sec:1/2/3`. Stored in frontmatter.
* **Container** — A placement that can hold children (date sections or parent items with sections).
* **Rank** — LexoRank string determining sort order within a container. Stored in frontmatter.
* **Alias** — Human-friendly slug mapping to an item ID (e.g., `my-project` → UUID).
* **Path** — User-facing expression that may include relative dates (`today`), aliases, or navigation tokens (`.`, `..`). Resolved to placement at request time.
* **Island** — Preact component in Fresh that hydrates on the client for interactivity.

---

## 3. Architecture

### 3.1 Data Layer (In-Memory Index)

On Fresh server startup:

1. **Read workspace config** (`workspace.json`) to get timezone
2. **Scan `items/YYYY/MM/DD/*.md`** and parse YAML frontmatter
3. **Build in-memory maps**:
   - `itemsById: Map<ItemId, ItemMeta & { bodyPath: string }>`
     - Stores id, kind, status, placement, rank, created_at, updated_at, alias, tags, title (extracted from first H1)
   - `childrenByContainer: Map<ContainerKey, ChildRef[]>`
     - ContainerKey: `date:YYYY-MM-DD` or `parent:<uuid>|sec:1/2/3`
     - ChildRef: `{ id: ItemId, rank: Rank }`
     - Arrays are pre-sorted by rank (ascending), tie-break by created_at
   - `aliasToId: Map<CanonicalAlias, ItemId>`
     - CanonicalAlias: NFKC + casefold normalized

**Why not use `.index/`?**
`.index/` is a cache; frontmatter is authoritative. MVP builds index from frontmatter on startup. Future optimization: check `.index/` freshness and rebuild if stale.

### 3.2 Domain Logic

**Placement resolution**:
- Input: user path string (e.g., `today/1/2`, `my-project/3`)
- Output: canonical placement (e.g., `date:2026-02-04`, `parent:<uuid>|sec:1/2/3`)
- Process:
  1. Parse path into tokens
  2. Resolve relative dates (`today`, `tm`, `mon+`) using workspace timezone
  3. Resolve aliases to item IDs
  4. Normalize to placement format

**Child listing**:
- Input: container key (placement)
- Output: sorted array of `ChildRef[]` from `childrenByContainer` map
- Rank-based ordering is pre-computed at index time

**Item retrieval**:
- Input: item ID or alias
- Output: `ItemMeta` + markdown body (read from `bodyPath` on demand)

### 3.3 Presentation Layer (Fresh Routes)

#### `/d/:date` – Date container listing

- Parse `:date` (accept `YYYY-MM-DD`, `today`, `tm`, etc.)
- Resolve to absolute date
- Lookup `childrenByContainer.get("date:YYYY-MM-DD")`
- Render list of children (title, kind, status, rank order)

#### `/i/:id` – Item detail

- Lookup `itemsById.get(id)`
- Render: title (H1), kind badge, status badge, created/updated timestamps, placement breadcrumb, parent link, markdown body
- Show children list if any (from `childrenByContainer`)

#### `/a/:alias` – Alias redirect

- Normalize alias (NFKC + casefold)
- Lookup `aliasToId.get(canonicalAlias)`
- Redirect to `/i/:id` (303 See Other)

#### `/tree/:rootId` – Tree view

- Lookup item by ID
- Render item + children (recursive up to N levels, default 2)
- Use island for expand/collapse interactivity

#### `/search?q=...` – Search

- Filter `itemsById` entries by query (title, alias, tags)
- Render results list (title, kind, placement)
- Use island for incremental filtering

### 3.4 Islands (Client-Side Interactivity)

- **TreeNode.tsx**: Expand/collapse children in tree view
- **SearchFilter.tsx**: Live filtering of search results (no server roundtrip)
- **TagFilter.tsx** (future): Toggle tag filters

Keep islands minimal; most rendering is SSR.

---

## 4. User-Facing Changes

### 4.1 New Features / Interfaces

**New Deno task**:
```bash
deno task fresh-dev  # Start Fresh dev server (http://localhost:8000)
```

**Routes**:
```
GET /d/today          # Today's items
GET /d/2026-02-04     # Specific date
GET /d/tm             # Tomorrow
GET /i/<uuid>         # Item detail by ID
GET /a/my-project     # Resolve alias, redirect to /i/<uuid>
GET /tree/<uuid>      # Tree view starting from item
GET /search?q=foo     # Search items by title/alias/tags
```

**Example flow**:
1. User opens `http://localhost:8000/d/today`
2. Sees list of items created/placed under today's date, sorted by rank
3. Clicks an item title → navigates to `/i/<uuid>`
4. Sees item detail with full markdown body, parent link, children list
5. Clicks alias link → redirects via `/a/<alias>` to item detail

### 4.2 Behavior Changes

* No CLI behavior changes; this is a new UI surface
* `.index/` remains optional (Fresh builds its own in-memory index on startup)

---

## 5. Implementation Notes

### 5.1 Fresh Setup

* Use Fresh v2.2 (latest as of 2026-02-04)
* Directory structure:
  ```
  fresh/
    main.ts              # Fresh server entry
    fresh.config.ts      # Fresh configuration
    routes/
      d/[date].tsx       # Date listing route
      i/[id].tsx         # Item detail route
      a/[alias].tsx      # Alias redirect route
      tree/[rootId].tsx  # Tree view route
      search.tsx         # Search route
    islands/
      TreeNode.tsx       # Tree expansion island
      SearchFilter.tsx   # Search filter island
    components/
      ItemCard.tsx       # Item display component
      Breadcrumb.tsx     # Placement breadcrumb
    lib/
      index.ts           # In-memory index builder
      domain.ts          # Placement resolution, child listing
      markdown.ts        # Markdown rendering
  ```

* Run via `deno task fresh-dev` (add to `deno.json` tasks)

### 5.2 Markdown Rendering

* Use `marked` or `micromark` for rendering
* Sanitize HTML output (prevent XSS)
* Syntax highlighting for code blocks (optional: `highlight.js`)

### 5.3 Performance Considerations

* **Startup**: ~1000 items × ~1KB frontmatter = ~1MB memory. Fast enough.
* **Detail pages**: Read markdown body on-demand (not all 1000 bodies in memory)
* **Caching**: Consider HTTP caching headers (ETag, Cache-Control) for static assets

### 5.4 Error Handling

* **Item not found**: Show 404 page with helpful message
* **Invalid date**: Show error message with valid date format examples
* **Alias not found**: Show 404 with list of suggested aliases
* **Parse errors**: Log and skip malformed items during index build; show warning in UI

---

## 6. Error Handling & Edge Cases

### 6.1 Item moved to another placement

* Item file exists under `items/YYYY/MM/DD/` but `placement` frontmatter points elsewhere
* **Behavior**: Item appears only in its current placement (from frontmatter), not in the original date listing
* **UI**: Show placement breadcrumb to indicate logical location

### 6.2 Orphaned items (placement parent missing)

* Item's `placement` references a parent item that doesn't exist
* **Behavior**: Item is excluded from parent's children list
* **UI**: Show warning on item detail page ("Parent item not found")

### 6.3 Circular placement (should never happen)

* If graph has a cycle (A → B → C → A)
* **Behavior**: Tree traversal uses visited set to detect cycles, stops expansion
* **UI**: Show warning ("Cycle detected in tree")

### 6.4 Invalid frontmatter

* YAML parse error, missing required fields, invalid values
* **Behavior**: Skip item during index build, log error
* **UI**: Show warning in dev mode ("N items skipped due to errors")

### 6.5 Relative date outside valid range

* User requests `GET /d/100d+` (100 days in the future)
* **Behavior**: Resolve to absolute date, show empty listing if no items
* **UI**: Show date breadcrumb, no special error

---

## 7. Testing Strategy

* **Unit tests**: Placement resolution, alias normalization, rank sorting
* **Integration tests**: In-memory index building, child listing, item retrieval
* **E2E tests** (via browser MCP tools):
  1. Navigate to `/d/today`, verify items displayed
  2. Click item, verify detail page shows correct data
  3. Resolve alias via `/a/<alias>`, verify redirect to `/i/<uuid>`
  4. Expand tree node, verify children rendered
  5. Search by title, verify results filtered
* **Manual testing**: Visual inspection of UI, edge cases (empty dates, orphaned items)

---

## 8. Stories (To Be Created)

Stories will be created incrementally during development:

1. **Fresh project setup** – Bootstrap Fresh v2.2, add dev task ✓
2. **Date listing route** – `/d/:date` with items list (includes infra: workspace config, repositories)
3. **Item detail route** – `/i/:id` with markdown rendering
4. **Alias redirect route** – `/a/:alias` with canonical normalization
5. **Tree view route** – `/tree/:rootId` with island for expansion
6. **Search route** – `/search?q=...` with client-side filtering island
7. **Error handling** – 404 pages, orphan warnings, cycle detection
8. **UI polish** – Styling, breadcrumbs, badges, responsive layout

Note: In-memory index building is done as part of Story 2, not as a separate story.

Each story will have its own Given-When-Then acceptance criteria.
